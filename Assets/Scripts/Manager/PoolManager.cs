using System.Collections.Generic;
using UnityEngine.Events;
using UnityEngine;
using System.Runtime.InteropServices.WindowsRuntime;
using System.Linq;

//可以改为用ID存储到缓存池
public class PoolData
{

    //缓存池中可能有多个不同种类的物体，为方便管理故需要设置一个父物体
    public GameObject fatherObj;
    //使用List链式结构来存储物体
    public List<GameObject> poolList;
    private GameObject poolObj;

    //构造函数，进行PoolData的一些初始化
    public PoolData(GameObject obj, GameObject _poolObj, bool resetFather = false)
    {
        GeneratePar(obj, _poolObj);
    }
    private void GeneratePar(GameObject obj, GameObject _poolObj)
    {
        string fatherName = obj.name;
        fatherObj = new GameObject(fatherName);
        poolObj = _poolObj;
        fatherObj.transform.parent = poolObj.transform;
        poolList = new List<GameObject>();
        PushObj(obj);
    }
    //将物体push进缓存池
    public void PushObj(GameObject obj)
    {
        //存储、设置父物体、隐藏
        poolList.Add(obj);
        obj.SetActive(false);
        /*if (fatherObj == null)
        {
            fatherObj = obj;
            fatherObj.transform.parent = poolObj.transform;
        }*/
        if (fatherObj == null) GeneratePar(obj, PoolManager.GetInstance().poolObj);
        obj.transform.SetParent(fatherObj.transform);
    }
    //将物体从缓存池取出
    public GameObject GetObj()
    {
        if (poolList.Count <= 0) return null;

        GameObject obj = null;
        obj = poolList[0];
        poolList.RemoveAt(0);
        if (!obj) return obj;
        obj.SetActive(true);
        obj.transform.parent = null;
        return obj;
    }
}

//对缓存池进行管理的单例模式类
public class PoolManager : BaseManager<PoolManager>
{
    public bool isActive = true;
    //使用字典存储数据
    private Dictionary<string, PoolData> poolDic
        = new Dictionary<string, PoolData>();
    //缓存池的父物体
    public GameObject poolObj;

    public override void Reset()
    {
        Clear();
    }

    /// <summary>
    /// 从对象池中取物体
    /// </summary>
    /// <param name="poolName">物体所在对象池名称（就是想取出的物体名称）</param>
    /// <returns></returns>
    public async void GetObj(string poolName, UnityAction<GameObject> callback, ResourceType resourceType)
    {
        GameObject t = null;
        if (poolDic.ContainsKey(poolName) && poolDic[poolName].poolList.Count > 0)
        {
            t = poolDic[poolName].GetObj();
            if (t != null) callback(t);
        }

        //GameObject t1 = null;
        else
        {
            await ResourceManager.Instance.LoadRes<GameObject>(poolName, result =>
            {
                if (!result)
                {
                    Debug.Log($"对象池新生成{poolName}对象不正确，可能是给出的对象名称/加载路径/资源类型不正确");
                    return;
                }
                t = GameObject.Instantiate(result);
                callback(t);
            }, () => { }, resourceType);
        }
        /*if(t1!=null) t = GameObject.Instantiate(t1);
        return t;*/
    }

    /// <summary>
    /// 如果已经给出了初始物体，就根据给出的物体取
    /// </summary>
    /// <param name="poolName"></param>
    /// <param name="obj"></param>
    /// <returns></returns>
    public GameObject GetObj(string poolName, GameObject obj)
    {
        if (!isActive) return null;
        if (poolDic.ContainsKey(poolName) && poolDic[poolName].poolList.Count > 0)
        {
            GameObject t;
            t = poolDic[poolName].GetObj();
            if (t != null) return t;
        }

        if (!obj) return null;
        return GameObject.Instantiate(obj);
    }

    //从缓存池中取出
    public void GetObj(string objName, UnityAction<GameObject> callback)
    {
        //若缓存池中存在，取出
        if (poolDic.ContainsKey(objName) && poolDic[objName].poolList.Count > 0)
            callback(poolDic[objName].GetObj());
        //若不存在则使用ResMgr动态加载
        else
        {
            //注意生成的物体的this.name此时并不是objName，而是objName（clone），若是使用this.name进行PushObj的话，则无法使用objName从字典中进行Get
            ResourceManager.Instance.LoadAsync<GameObject>(objName, callback);
        }
    }

    //使用时注意objName，使用动态加载出来的物体的this.name会在原名后加上（clone)字样，此时使用this.name进行PushObj操作时，实际是创建了另一个池子，所以使用时推荐直接使用"objName"的方式而不是this.name的方式
    /// <summary>
    /// 将物体加入对象池
    /// </summary>
    /// <param name="poolName">想要加入的池子类型</param>
    /// <param name="obj">物品本身</param>
    public void PushObj(string poolName, GameObject obj)
    {
        if (poolObj == null)
            poolObj = new GameObject("Pool");//实例化，此后所以在缓存池的物体全部为
        if (poolDic.ContainsKey(poolName))//如果缓存池中已经存在其类型，则将物体加入其中
            poolDic[poolName].PushObj(obj);
        else//若缓存池中没有此类物体，则添加至字典
            poolDic.Add(poolName, new PoolData(obj, poolObj));
        //采用的结构是PoolData 类，里面含有链式结构PoolList 
    }
    //清空某个池子
    public void Clear(string poolName)
    {
        if (poolDic.ContainsKey(poolName))
        {
            for (int i = 0; i < poolDic[poolName].poolList.Count; i++)
            {
                GameObject.Destroy(poolDic[poolName].poolList[i]);
            }
            GameObject.Destroy(poolDic[poolName].fatherObj);
            poolDic.Remove(poolName);
        }
    }
    //清空缓存池
    public void Clear()
    {
        //isActive = false;
        for (int i = 0; i < poolDic.Count; i++)
        {
            for (int j = 0; j < poolDic.ElementAt(i).Value.poolList.Count; j++)
            {
                GameObject.Destroy(poolDic.ElementAt(i).Value.poolList[j]);
            }
            GameObject.Destroy(poolDic.ElementAt(i).Value.fatherObj);
        }

        poolDic.Clear();
        GameObject.Destroy(poolObj);
        poolObj = null;
    }
}